# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import models, fields, api
from psycopg2 import OperationalError
import logging

_logger = logging.getLogger(__name__)

DEFAULT_BLOCKING_LEVEL = 'error'


class AccountEdiDocument(models.Model):
    _name = 'account.edi.document'
    _description = 'Electronic Document'

    # == Stored fields ==
    edi_type = fields.Char(required=True)
    res_model = fields.Char('Related Document Model Name', required=True, index=True)
    res_id = fields.Many2oneReference('Related Document ID', index=True, required=True, model_field='res_model')
    edi_format_id = fields.Many2one('account.edi.format', required=True)
    attachment_id = fields.Many2one('ir.attachment', help='The file generated by edi_format_id when the record is posted (and this document is processed).')
    state = fields.Selection([('to_send', 'To Send'), ('sent', 'Sent'), ('to_cancel', 'To Cancel'), ('cancelled', 'Cancelled')])
    error = fields.Html(help='The text of the last error that happened during EDI operation.')
    blocking_level = fields.Selection(
        selection=[('info', 'Info'), ('warning', 'Warning'), ('error', 'Error')],
        help="Blocks the document current operation depending on the error severity :\n"
        "  * Info: the document is not blocked and everything is working as it should.\n"
        "  * Warning : there is an error that doesn't prevent the current Electronic Invoicing operation to succeed.\n"
        "  * Error : there is an error that blocks the current Electronic Invoicing operation.")

    # == Not stored fields ==
    name = fields.Char(related='attachment_id.name')
    edi_format_name = fields.Char(string='Format Name', related='edi_format_id.name')

    _sql_constraints = [
        (
            'unique_edi_document_by_rec_by_format',
            'UNIQUE(edi_format_id, res_model, res_id)',
            'Only one edi document by record by format',
        ),
    ]

    def _prepare_jobs(self):
        """Creates a list of jobs to be performed by '_process_job' for the documents in self.
        Each document represent a job, BUT if multiple documents have the same state, edi_format_id,
        edi_type and company_id AND the edi_format_id supports batching, they are grouped
        into a single job.

        :returns:         A list of recordsets of documents, each consisting of a job.
        If edi_format_id does not support batch, each recordset has a length of one.
        """

        # Classify jobs by (edi_format, edi_doc.state, edi_type, company_id, custom_key)
        to_process = {}
        documents = self.filtered(lambda d: d.state in ('to_send', 'to_cancel') and d.blocking_level != 'error')
        for edi_doc in documents:
            rec = self.env[edi_doc.res_model].browse(edi_doc.mapped('res_id'))
            edi_format = edi_doc.edi_format_id

            custom_key = edi_format._get_batch_key(rec, edi_doc.edi_type, edi_doc.state)
            company = rec.company_id if 'company_id' in rec else self.env.company  # in case model doesn't have company_id
            key = (edi_format, edi_doc.state, edi_doc.edi_type, company, custom_key)
            to_process.setdefault(key, self.env['account.edi.document'])
            to_process[key] |= edi_doc

        # Order records based on the type and create batches.
        jobs = []
        priorities = {edi_format: edi_format._get_edi_priority() for edi_format in documents.edi_format_id}
        for key, documents in to_process.items():
            edi_format, state, edi_type, company_id, custom_key = key
            batch = self.env['account.edi.document']
            for doc in documents:
                if edi_format._support_batching(rec, edi_type, state, company_id):
                    batch |= doc
                else:
                    jobs.append(doc)
            if batch:
                jobs.append(batch)
        return sorted(jobs, key=lambda docs: priorities[docs.edi_format_id][docs[0].edi_type])

    def _cancel_records(self, records):
        return

    @api.model
    def _process_job(self, documents):
        """Post or cancel documents by calling the related methods on edi_format_id.

        :param documents: The documents related to this job. If edi_format_id does not support batch, length is one
        """
        def _postprocess_post_edi_results(documents, edi_result):
            attachments_to_unlink = self.env['ir.attachment']
            for document in documents:
                rec = self.env[document.res_model].browse(document.mapped('res_id'))
                rec_result = edi_result.get(rec, {})
                if rec_result.get('attachment'):
                    old_attachment = document.attachment_id
                    document.attachment_id = rec_result['attachment']
                    if not old_attachment.res_model or not old_attachment.res_id:
                        attachments_to_unlink |= old_attachment
                if rec_result.get('success') is True:
                    document.state = 'sent'
                else:
                    document.write({
                        'error': rec_result.get('error', False),
                        'blocking_level': rec_result.get('blocking_level', DEFAULT_BLOCKING_LEVEL) if 'error' in rec_result else False,
                    })

            # Attachments that are not explicitly linked to a business model could be removed because they are not
            # supposed to have any traceability from the user.
            attachments_to_unlink.unlink()

        def _postprocess_cancel_edi_results(documents, edi_result):
            records_to_cancel = {}
            attachments_to_unlink = self.env['ir.attachment']
            for document in documents:
                rec = self.env[document.res_model].browse(document.mapped('res_id'))
                rec_result = edi_result.get(rec, {})
                if rec_result.get('success') is True:
                    old_attachment = document.attachment_id
                    document.write({
                        'state': 'cancelled',
                        'error': False,
                        'attachment_id': False,
                        'blocking_level': False,
                    })

                    if document.edi_type not in records_to_cancel:
                        records_to_cancel[document.edi_type] = self.env[document.res_model]
                    records_to_cancel[document.edi_type] |= rec

                    if not old_attachment.res_model or not old_attachment.res_id:
                        attachments_to_unlink |= old_attachment

                else:
                    document.write({
                        'error': rec_result.get('error', False),
                        'blocking_level': rec_result.get('blocking_level', DEFAULT_BLOCKING_LEVEL) if rec_result.get('error') else False,
                    })

            if records_to_cancel:
                self._cancel_records(records_to_cancel)

            # Attachments that are not explicitly linked to a business model could be removed because they are not
            # supposed to have any traceability from the user.
            attachments_to_unlink.unlink()

        edi_format = documents.edi_format_id
        state = documents[0].state
        recs = self.env[documents.res_model].browse(documents.mapped('res_id'))
        if state == 'to_send':
            edi_result = edi_format._post_edi(recs, documents.edi_type)
            _postprocess_post_edi_results(documents, edi_result)
        if state == 'to_cancel':
            edi_result = edi_format._cancel_edi(recs, documents.edi_type)
            _postprocess_cancel_edi_results(documents, edi_result)

    def _process_documents_no_web_services(self):
        """ Post and cancel all the documents that don't need a web service.
        """
        jobs = self.filtered(lambda d: not d.edi_format_id._needs_web_services())._prepare_jobs()
        for documents in jobs:
            self._process_job(documents)

    def _process_documents_web_services(self, job_count=None, with_commit=True):
        ''' Post and cancel all the documents that need a web service.

        :param job_count:   The maximum number of jobs to process if specified.
        :param with_commit: Flag indicating a commit should be made between each job.
        :return:            The number of remaining jobs to process.
        '''
        all_jobs = self.filtered(lambda d: d.edi_format_id._needs_web_services())._prepare_jobs()
        jobs_to_process = all_jobs[0:job_count] if job_count else all_jobs

        for documents in jobs_to_process:
            recs_to_lock = self.env[documents.res_model].browse(documents.filtered(lambda doc: doc.state == 'to_cancel').mapped('res_id'))
            attachments_potential_unlink = documents.attachment_id.filtered(lambda a: not a.res_model and not a.res_id)
            try:
                with self.env.cr.savepoint(flush=False):
                    self._cr.execute('SELECT * FROM account_edi_document WHERE id IN %s FOR UPDATE NOWAIT', [tuple(documents.ids)])
                    if recs_to_lock:
                        self._cr.execute('SELECT * FROM ' + recs_to_lock._table + ' WHERE id IN %s FOR UPDATE NOWAIT', [tuple(recs_to_lock.ids)])

                    # Locks the attachments that might be unlinked
                    if attachments_potential_unlink:
                        self._cr.execute('SELECT * FROM ir_attachment WHERE id IN %s FOR UPDATE NOWAIT', [tuple(attachments_potential_unlink.ids)])

                    self._process_job(documents)
            except OperationalError as e:
                if e.pgcode == '55P03':
                    _logger.debug('Another transaction already locked documents rows. Cannot process documents.')
                else:
                    raise e
            else:
                if with_commit and len(jobs_to_process) > 1:
                    self.env.cr.commit()

        return len(all_jobs) - len(jobs_to_process)

    @api.model
    def _cron_process_documents_web_services(self, job_count=None):
        ''' Method called by the EDI cron processing all web-services.

        :param job_count: Limit explicitely the number of web service calls. If not provided, process all.
        '''
        edi_documents = self.search([('state', 'in', ('to_send', 'to_cancel'))])
        nb_remaining_jobs = edi_documents._process_documents_web_services(job_count=job_count)

        # Mark the CRON to be triggered again asap since there is some remaining jobs to process.
        if nb_remaining_jobs > 0:
            self.env.ref('edi.ir_cron_edi_network')._trigger()

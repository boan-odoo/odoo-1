# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import models, fields, api, tools, _


REWARD_SALE_ORDER_LINE_SEQUENCE = 200


class SaleOrder(models.Model):
    _inherit = 'sale.order'

    won_loyalty_points = fields.Float(help='The amount of Loyalty points the customer won with this order', default=0.0)
    spent_loyalty_points = fields.Float(help='The amount of Loyalty points the customer spent with this order', default=0.0)
    available_loyalty_points = fields.Float(help='The number of points still available to spend within this order', compute='_compute_available_loyalty_points')
    reached_loyalty_points = fields.Float(help='The number of points that will be available to spend after this order completion', compute='_compute_reached_loyalty_points')

    @api.depends('won_loyalty_points', 'spent_loyalty_points', 'state')
    def _compute_reached_loyalty_points(self):
        for order in self:
            order.reached_loyalty_points = order.partner_id.loyalty_points
            # Points are already spent from balance when the order is sent
            if order.state not in ('sent', 'sale', 'done'):
                order.reached_loyalty_points -= order.spent_loyalty_points
            # Points are already received on balance if the order is paid
            if order.state not in ('sale', 'done'):
                order.reached_loyalty_points += order.won_loyalty_points

    @api.depends('spent_loyalty_points')
    def _compute_available_loyalty_points(self):
        for order in self:
            order.available_loyalty_points = order.partner_id.loyalty_points - order.spent_loyalty_points

    def _compute_website_order_line(self):
        """ This method will merge multiple discount lines generated by a same program
            into a single one (temporary line with `new()`).
            This case will only occur when the program is a discount applied on multiple
            products with different taxes.
            In this case, each taxes will have their own discount line. This is required
            to have correct amount of taxes according to the discount.
            But we wan't these lines to be `visually` merged into a single one in the
            e-commerce since the end user should only see one discount line.
            This is only possible since we don't show taxes in cart.
            eg:
                line 1: 10% discount on product with tax `A` - $15
                line 2: 10% discount on product with tax `B` - $11.5
                line 3: 10% discount on product with tax `C` - $10
            would be `hidden` and `replaced` by
                line 1: 10% discount - $36.5

            Note: The line will be created without tax(es) and the amount will be computed
                depending if B2B or B2C is enabled.
        """
        # Discounts must be adjusted on latest known amount
        # This avoids having a too high discount after e.g. a coupon is applied
        self._cart_adjust_rewards()
        super()._compute_website_order_line()
        for order in self:
            touched = False
            for line in order.order_line.filtered(
                lambda line: line.loyalty_reward_id and line.is_main_loyalty_reward
            ):
                reward = line.loyalty_reward_id
                secondary_lines = order.order_line.filtered(
                    lambda l: l.loyalty_reward_id == reward and not l.is_main_loyalty_reward
                )
                if secondary_lines:
                    if self.env.user.has_group('sale.group_show_price_subtotal'):
                        total_discount = sum(secondary_lines.mapped('price_subtotal'))
                    else:
                        total_discount = sum(secondary_lines.mapped('price_total'))
                    order.website_order_line += self.env['sale.order.line'].new({
                        'name': line.name,
                        'product_id': line.product_id.id,
                        'loyalty_reward_id': line.loyalty_reward_id.id,
                        'is_main_loyalty_reward': True,
                        'product_uom_qty': 1,
                        'product_uom': line.product_uom.id,
                        'order_id': line.order_id.id,
                        'price_unit': total_discount,
                        'tax_id': None,
                        'sequence': line.sequence,
                    })
                    order.website_order_line -= secondary_lines
                    order.website_order_line -= line
                    touched = True
            if touched:
                order.website_order_line = order.website_order_line.sorted('sequence')

    def write(self, vals):
        """Adjust partner's points on state transition:
        - spend points as soon as the order is sent (for delayed payment method)
        - gain points only when payment is received
        - restore points on cancel
        """
        new_state = vals.get('state')
        if new_state:
            for order in self.filtered(lambda order: order.partner_id):
                if order.state == 'draft' and new_state in ('sent', 'sale', 'done') \
                        and order.spent_loyalty_points > 0:
                    order.partner_id.loyalty_points -= order.spent_loyalty_points
                if order.state in ('draft', 'sent') and new_state in ('sale', 'done') \
                        and order.won_loyalty_points > 0:
                    order.partner_id.loyalty_points += order.won_loyalty_points
                if order.state in ('sent', 'sale') and new_state == 'cancel' \
                        and order.spent_loyalty_points > 0:
                    order.partner_id.loyalty_points += order.spent_loyalty_points
                if order.state in ('sale') and new_state == 'cancel' \
                        and order.won_loyalty_points > 0:
                    order.partner_id.loyalty_points -= order.won_loyalty_points
        return super(SaleOrder, self).write(vals)

    def _cart_find_product_line(self, product_id=None, line_id=None, **kwargs):
        if not line_id:
            kwargs['extra_domain'] = [('loyalty_reward_id', '=', False)]
        return super()._cart_find_product_line(product_id, line_id, **kwargs)

    def _cart_update(self, product_id=None, line_id=None, add_qty=0, set_qty=0, **kwargs):
        values = super(SaleOrder, self)._cart_update(product_id, line_id, add_qty, set_qty, **kwargs)
        self._cart_adjust_rewards()
        return values

    def _cart_adjust_rewards(self):
        for order in self:
            # 1. make sure no reward has a price yet to correctly compute discounts
            secondary_lines = []
            for line in order.order_line.filtered(lambda line: line.loyalty_reward_id):
                if line.is_main_loyalty_reward:
                    line.price_unit = 0
                    if line.loyalty_reward_id.reward_type == 'discount' and line.loyalty_reward_id.discount_type == 'percentage':
                        line.product_uom_qty = 1
                        line.tax_id = None
                else:
                    secondary_lines.append(line)
            for line in secondary_lines:
                line.unlink()

            # 2. determine value of each discount:
            # - 2.1. take into account non-global percentage discounts
            # - 2.2. take into account fixed price discounts (cannot be higher than what remains)
            # - 2.3. take into account percentage discounts cumulatively (% of what remains)

            def discount_precedence(line):
                if line.loyalty_reward_id.discount_type == 'percentage':
                    return 3 if line.loyalty_reward_id.discount_apply_on == 'on_order' else 1
                else:
                    return 2

            empty_lines = []
            new_lines = []
            discount_lines = order.order_line.filtered(lambda l: l.loyalty_reward_id and l.loyalty_reward_id.reward_type == 'discount')
            for line in discount_lines.sorted(discount_precedence):
                reward = self.env['loyalty.reward'].browse(int(line.loyalty_reward_id))
                discount_per_tax = order._get_cart_loyalty_discount(reward)
                if discount_per_tax:
                    if len(discount_per_tax) == 1:
                        taxes = list(discount_per_tax)[0]
                        line.price_unit = -discount_per_tax.get(taxes)
                        line.tax_id = taxes
                    else:
                        for taxes in list(discount_per_tax):
                            name = _(
                                "%(name)s - On product with following taxes: %(taxes)s",
                                name=reward.name,
                                taxes=", ".join(taxes.mapped('name')),
                            ) if taxes else _("%s - On product without taxes", reward.name)
                            new_lines.append({
                                'name': name,
                                'product_id': line.product_id.id,
                                'loyalty_reward_id': line.loyalty_reward_id.id,
                                'is_main_loyalty_reward': False,
                                'product_uom_qty': 1,
                                'product_uom': line.product_uom.id,
                                'order_id': line.order_id.id,
                                'price_unit': -discount_per_tax[taxes],
                                'tax_id': [fields.Command.link(tax.id) for tax in taxes],
                                # for _cart_find_product_line() to locate the main reward line
                                'sequence': 1 + line.sequence,
                            })
                else:
                    empty_lines.append(line)
            for line in empty_lines:
                line.unlink()
            self.env['sale.order.line'].create(new_lines)
            if order.website_id.has_loyalty:
                order.recompute_loyalty_points(order.website_id.loyalty_id.id)

    def _get_cart_loyalty_discount(self, reward):
        discount_per_tax = {}
        order_total = sum(self.order_line.mapped('price_subtotal'))
        remaining_amount = [min(order_total, reward.discount_max_amount) if reward.discount_max_amount > 0 else order_total]
        def track(taxes, discount):
            discount = min(remaining_amount[0], discount)
            if discount:
                taxes = self.fiscal_position_id.map_tax(taxes)
                discount_per_tax[taxes] = discount_per_tax.get(taxes, 0) + discount
                remaining_amount[0] -= discount

        lines = self.order_line.filtered(lambda x: not x._is_not_sellable_line())
        if reward.discount_type == 'percentage':
            if reward.discount_apply_on == 'on_order':
                for line in lines:
                    track(line.tax_id, line.currency_id.round(line.price_subtotal * (reward.discount_percentage / 100)))
            elif reward.discount_apply_on == 'specific_products':
                for prod in reward.discount_specific_product_ids:
                    for line in lines.filtered(lambda line: line.product_id.id == prod.id):
                        track(line.tax_id, line.currency_id.round(line.price_subtotal * (reward.discount_percentage / 100)))
            elif reward.discount_apply_on == 'cheapest_product':
                price = 0
                tax = None
                for line in lines:
                    if price == 0 or price > line.price_unit and line.price_unit > 0:
                        discount = line.currency_id.round(line.price_unit * (reward.discount_percentage / 100))
                        price = line.price_unit
                        tax = line.tax_id
                track(tax, discount)
        else:
            taxes = reward.discount_product_id.taxes_id.filtered(lambda t: t.company_id.id == self.company_id.id)
            track(taxes, reward.discount_fixed_amount)

        return discount_per_tax

    def _cart_update_reward(self, reward_id=None, add_qty=1):
        if not reward_id:
            return
        if not self.partner_id:
            return
        if self.state != 'draft':
            return
        reward = self.env['loyalty.reward'].browse(int(reward_id))
        order_line = self.env['sale.order.line'].sudo().search([('order_id', '=', self.id), ('loyalty_reward_id', '=', reward_id)])
        if order_line:
            order_line.ensure_one()
            if reward.reward_type == 'gift':
                order_line.product_uom_qty += add_qty
        elif reward.reward_type == 'gift':
            # Take the default taxes on the reward product, mapped with the fiscal position
            taxes = reward.gift_product_id.taxes_id.filtered(lambda t: t.company_id.id == self.company_id.id)
            if self.fiscal_position_id:
                taxes = self.fiscal_position_id.map_tax(taxes)
            order_line = self.env['sale.order.line'].create({
                'product_id': reward.gift_product_id.id,
                'loyalty_reward_id': reward.id,
                'is_main_loyalty_reward': True,
                'product_uom_qty': add_qty,
                'product_uom': reward.gift_product_id.uom_id.id,
                'order_id': self.id,
                'price_unit': 0,
                'tax_id': [fields.Command.link(tax.id) for tax in taxes],
                'sequence': REWARD_SALE_ORDER_LINE_SEQUENCE,
            })
        elif reward.reward_type == 'discount':
            product = reward.discount_product_id
            if not product:
                return
            taxes = product.taxes_id.filtered(lambda t: t.company_id.id == self.company_id.id)
            if self.fiscal_position_id:
                taxes = self.fiscal_position_id.map_tax(taxes)
            order_line = self.env['sale.order.line'].create({
                'product_id': product.id,
                'loyalty_reward_id': reward.id,
                'is_main_loyalty_reward': True,
                'product_uom_qty': 1,
                'product_uom': product.uom_id.id,
                'order_id': self.id,
                'price_unit': 0,  # computed by _cart_adjust_rewards
                'tax_id': [fields.Command.link(tax.id) for tax in taxes],
                'sequence': REWARD_SALE_ORDER_LINE_SEQUENCE,
            })
        self._cart_adjust_rewards()
        website = self.env['website'].get_current_website()
        self.recompute_loyalty_points(website.loyalty_id.id)

    def _get_won_points(self, loyalty):
        """The total of points won, excluding the points spent on rewards"""
        total_points = 0
        for line in self.order_line.filtered(lambda line: not line.loyalty_reward_id):
            line_points = 0
            for rule in loyalty.rule_ids:
                rule_points = 0
                if rule.is_product_valid(line.product_id):
                    rule_points += rule.points_quantity * line.product_uom_qty
                    rule_points += rule.points_currency * line.price_total
                if rule_points > line_points:
                    line_points = rule_points

            total_points += line_points

        total_points += self.amount_total * loyalty.points
        return max(0, tools.float_round(total_points, 0, rounding_method='HALF-UP'))

    def _get_spent_points(self):
        """The total number of points spent on rewards"""
        points = 0
        for line in self.order_line.filtered(lambda line: line.loyalty_reward_id and line.is_main_loyalty_reward):
            line_points = line.product_uom_qty * line.loyalty_reward_id.point_cost
            points += tools.float_round(line_points, 0, rounding_method='HALF-UP')
        return max(0, points)

    def recompute_loyalty_points(self, loyalty_id):
        loyalty = self.env['loyalty.program'].browse(loyalty_id) if loyalty_id else None
        for order in self:
            if loyalty and self.partner_id.active:
                won_points = order._get_won_points(loyalty)
                if order.won_loyalty_points != won_points:
                    order.won_loyalty_points = won_points
                spent_points = order._get_spent_points()
                if order.spent_loyalty_points != spent_points:
                    order.spent_loyalty_points = spent_points
            else:
                if order.won_loyalty_points != 0:
                    order.won_loyalty_points = 0
                if order.spent_loyalty_points != 0:
                    order.spent_loyalty_points = 0

    def get_portal_loyalty_url(self):
        return self.get_portal_url().replace('orders', 'loyalty')

    def update_prices(self):
        """Recompute rewards after pricelist prices reset."""
        super().update_prices()
        if any(line.loyalty_reward_id for line in self.order_line):
            self._cart_adjust_rewards()


class SaleOrderLine(models.Model):
    _inherit = 'sale.order.line'

    loyalty_reward_id = fields.Many2one('loyalty.reward', string='Loyalty Reward', help='The loyalty reward of this line')
    is_main_loyalty_reward = fields.Boolean(string='Main Loyalty Reward', help='True only for the main line of a loyalty reward')

    def _is_not_sellable_line(self):
        return self.loyalty_reward_id.reward_type == 'discount' or super()._is_not_sellable_line()

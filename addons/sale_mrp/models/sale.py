# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from collections import defaultdict

from odoo import api, fields, models, _


class SaleOrder(models.Model):
    _inherit = 'sale.order'

    mrp_production_count = fields.Integer(
        "Count of MO generated",
        compute='_compute_mrp_production_count',
        groups='mrp.group_mrp_user')

    @api.depends('procurement_group_id.stock_move_ids.created_production_id.procurement_group_id.mrp_production_ids')
    def _compute_mrp_production_count(self):
        for sale in self:
            sale.mrp_production_count = len(sale.procurement_group_id.stock_move_ids.created_production_id.procurement_group_id.mrp_production_ids)

    def action_view_mrp_production(self):
        self.ensure_one()
        mrp_production_ids = self.procurement_group_id.stock_move_ids.created_production_id.procurement_group_id.mrp_production_ids.ids
        action = {
            'res_model': 'mrp.production',
            'type': 'ir.actions.act_window',
        }
        if len(mrp_production_ids) == 1:
            action.update({
                'view_mode': 'form',
                'res_id': mrp_production_ids[0],
            })
        else:
            action.update({
                'name': _("Manufacturing Orders Generated by %s", self.name),
                'domain': [('id', 'in', mrp_production_ids)],
                'view_mode': 'tree,form',
            })
        return action


class SaleOrderLine(models.Model):
    _inherit = 'sale.order.line'

    kit_bom_id = fields.Many2one(
        'mrp.bom', compute='_compute_kit_bom_id', string='BoM if the product is a kit', store=True)

    @api.depends('product_id', 'company_id')
    def _compute_kit_bom_id(self):
        for line in self:
            line.kit_bom_id = False
            if not line.product_id.bom_ids or 'phantom' not in line.product_id.bom_ids.mapped('type'):
                continue
            bom = self.env['mrp.bom']._bom_find(
                self.product_id, company_id=self.order_id.company_id.id, bom_type='phantom')[self.product_id]
            if bom:
                line.kit_bom_id = bom.id

    @api.depends('product_uom_qty', 'qty_delivered', 'product_id', 'state')
    def _compute_qty_to_deliver(self):
        """The inventory widget should now be visible in more cases if the product is consumable."""
        super(SaleOrderLine, self)._compute_qty_to_deliver()
        for line in self:
            if line.kit_bom_id:
                line.display_qty_widget = False
                continue
            if line.state == 'draft' and line.product_type == 'consu':
                components = line.product_id.get_components()
                if components and components != [line.product_id.id]:
                    line.display_qty_widget = True

    @api.depends('kit_bom_id')
    def _compute_move_ids(self):
        lines_kit = self.filtered(lambda l: l.kit_bom_id)
        super(SaleOrderLine, self - lines_kit)._compute_move_ids()
        move_by_product_so = defaultdict(lambda: self.env['stock.move'])
        for sale_order in lines_kit.order_id:
            sale_order_moves = set(sale_order.picking_ids.filtered(
                lambda p: p.location_dest_id.usage == 'customer' or p.location_id.usage == 'customer'
            ).move_lines.ids)
            for move in self.env['stock.move'].browse(sale_order_moves):
                move_by_product_so[(move.product_id, sale_order)] |= move

        for sale_line in lines_kit:
            dummy, lines = sale_line.kit_bom_id.explode(self.product_id, 1)
            products = self.env['product.product']
            for line in lines:
                products |= line[0].product_id
            moves = [move_by_product_so.get(
                (p, sale_line.order_id), self.env['stock.move']) for p in products]
            sale_line.move_ids = self.env['stock.move'].concat(*moves)

    def _get_moves_quantity(self):
        if not self.move_ids.bom_line_id:
            return super()._get_moves_quantity()
        qty_by_product = defaultdict(float)
        for move in self.move_ids:
            if move.state != 'done':
                continue
            if move.location_dest_id.usage == 'customer':
                qty_by_product[move.product_id] += move.quantity_done
            else:
                qty_by_product[move.product_id] -= move.quantity_done
        components_qty = self._get_bom_component_qty()
        quantity_minimal = min(qty / components_qty[p.id] for p,
                               qty in qty_by_product.items()) if qty_by_product else 0.0
        return fields.Float.round(quantity_minimal, precision_digits=0, rounding_method="DOWN")

    def _get_bom_component_qty(self):
        bom_quantity = self.product_uom._compute_quantity(1, self.kit_bom_id.product_uom_id)
        __, lines = self.kit_bom_id.explode(self.product_id, bom_quantity)
        components = defaultdict(float)
        for line, line_data in lines:
            product = line.product_id.id
            line_uom = line.product_uom_id
            qty = line_data['qty']

            product_uom = self.env['product.product'].browse(product).uom_id
            if line_uom.id != product_uom.id:
                qty = line_uom._compute_quantity(qty, product_uom)
            components[product] += qty
        return components

    def _get_qty_procurement(self, previous_product_uom_qty=False):
        # Specific case when we change the qty on a SO for a kit product.
        # We don't try to be too smart and keep a simple approach: we compare the quantity before
        # and after update, and return the difference. We don't take into account what was already
        # sent, or any other exceptional case.
        bom = self.env['mrp.bom']._bom_find(self.product_id, bom_type='phantom')[self.product_id]
        if bom and previous_product_uom_qty:
            return sum([previous_product_uom_qty.get(id, 0.0) for id in self.ids])
        return super(SaleOrderLine, self)._get_qty_procurement(previous_product_uom_qty=previous_product_uom_qty)
